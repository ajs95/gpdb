// Code generated by counterfeiter. DO NOT EDIT.
package configfakes

import (
	"sync"

	"github.com/greenplum-db/gpdb/gp/internal/config"
)

type FakeSegmentHostsNetworkConfig struct {
	GetInternalCidrStub        func() string
	getInternalCidrMutex       sync.RWMutex
	getInternalCidrArgsForCall []struct {
	}
	getInternalCidrReturns struct {
		result1 string
	}
	getInternalCidrReturnsOnCall map[int]struct {
		result1 string
	}
	GetIpListStub        func() []string
	getIpListMutex       sync.RWMutex
	getIpListArgsForCall []struct {
	}
	getIpListReturns struct {
		result1 []string
	}
	getIpListReturnsOnCall map[int]struct {
		result1 []string
	}
	GetIpRangeStub        func() config.IpRangeConfig
	getIpRangeMutex       sync.RWMutex
	getIpRangeArgsForCall []struct {
	}
	getIpRangeReturns struct {
		result1 config.IpRangeConfig
	}
	getIpRangeReturnsOnCall map[int]struct {
		result1 config.IpRangeConfig
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSegmentHostsNetworkConfig) GetInternalCidr() string {
	fake.getInternalCidrMutex.Lock()
	ret, specificReturn := fake.getInternalCidrReturnsOnCall[len(fake.getInternalCidrArgsForCall)]
	fake.getInternalCidrArgsForCall = append(fake.getInternalCidrArgsForCall, struct {
	}{})
	stub := fake.GetInternalCidrStub
	fakeReturns := fake.getInternalCidrReturns
	fake.recordInvocation("GetInternalCidr", []interface{}{})
	fake.getInternalCidrMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSegmentHostsNetworkConfig) GetInternalCidrCallCount() int {
	fake.getInternalCidrMutex.RLock()
	defer fake.getInternalCidrMutex.RUnlock()
	return len(fake.getInternalCidrArgsForCall)
}

func (fake *FakeSegmentHostsNetworkConfig) GetInternalCidrCalls(stub func() string) {
	fake.getInternalCidrMutex.Lock()
	defer fake.getInternalCidrMutex.Unlock()
	fake.GetInternalCidrStub = stub
}

func (fake *FakeSegmentHostsNetworkConfig) GetInternalCidrReturns(result1 string) {
	fake.getInternalCidrMutex.Lock()
	defer fake.getInternalCidrMutex.Unlock()
	fake.GetInternalCidrStub = nil
	fake.getInternalCidrReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeSegmentHostsNetworkConfig) GetInternalCidrReturnsOnCall(i int, result1 string) {
	fake.getInternalCidrMutex.Lock()
	defer fake.getInternalCidrMutex.Unlock()
	fake.GetInternalCidrStub = nil
	if fake.getInternalCidrReturnsOnCall == nil {
		fake.getInternalCidrReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getInternalCidrReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeSegmentHostsNetworkConfig) GetIpList() []string {
	fake.getIpListMutex.Lock()
	ret, specificReturn := fake.getIpListReturnsOnCall[len(fake.getIpListArgsForCall)]
	fake.getIpListArgsForCall = append(fake.getIpListArgsForCall, struct {
	}{})
	stub := fake.GetIpListStub
	fakeReturns := fake.getIpListReturns
	fake.recordInvocation("GetIpList", []interface{}{})
	fake.getIpListMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSegmentHostsNetworkConfig) GetIpListCallCount() int {
	fake.getIpListMutex.RLock()
	defer fake.getIpListMutex.RUnlock()
	return len(fake.getIpListArgsForCall)
}

func (fake *FakeSegmentHostsNetworkConfig) GetIpListCalls(stub func() []string) {
	fake.getIpListMutex.Lock()
	defer fake.getIpListMutex.Unlock()
	fake.GetIpListStub = stub
}

func (fake *FakeSegmentHostsNetworkConfig) GetIpListReturns(result1 []string) {
	fake.getIpListMutex.Lock()
	defer fake.getIpListMutex.Unlock()
	fake.GetIpListStub = nil
	fake.getIpListReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeSegmentHostsNetworkConfig) GetIpListReturnsOnCall(i int, result1 []string) {
	fake.getIpListMutex.Lock()
	defer fake.getIpListMutex.Unlock()
	fake.GetIpListStub = nil
	if fake.getIpListReturnsOnCall == nil {
		fake.getIpListReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.getIpListReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeSegmentHostsNetworkConfig) GetIpRange() config.IpRangeConfig {
	fake.getIpRangeMutex.Lock()
	ret, specificReturn := fake.getIpRangeReturnsOnCall[len(fake.getIpRangeArgsForCall)]
	fake.getIpRangeArgsForCall = append(fake.getIpRangeArgsForCall, struct {
	}{})
	stub := fake.GetIpRangeStub
	fakeReturns := fake.getIpRangeReturns
	fake.recordInvocation("GetIpRange", []interface{}{})
	fake.getIpRangeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSegmentHostsNetworkConfig) GetIpRangeCallCount() int {
	fake.getIpRangeMutex.RLock()
	defer fake.getIpRangeMutex.RUnlock()
	return len(fake.getIpRangeArgsForCall)
}

func (fake *FakeSegmentHostsNetworkConfig) GetIpRangeCalls(stub func() config.IpRangeConfig) {
	fake.getIpRangeMutex.Lock()
	defer fake.getIpRangeMutex.Unlock()
	fake.GetIpRangeStub = stub
}

func (fake *FakeSegmentHostsNetworkConfig) GetIpRangeReturns(result1 config.IpRangeConfig) {
	fake.getIpRangeMutex.Lock()
	defer fake.getIpRangeMutex.Unlock()
	fake.GetIpRangeStub = nil
	fake.getIpRangeReturns = struct {
		result1 config.IpRangeConfig
	}{result1}
}

func (fake *FakeSegmentHostsNetworkConfig) GetIpRangeReturnsOnCall(i int, result1 config.IpRangeConfig) {
	fake.getIpRangeMutex.Lock()
	defer fake.getIpRangeMutex.Unlock()
	fake.GetIpRangeStub = nil
	if fake.getIpRangeReturnsOnCall == nil {
		fake.getIpRangeReturnsOnCall = make(map[int]struct {
			result1 config.IpRangeConfig
		})
	}
	fake.getIpRangeReturnsOnCall[i] = struct {
		result1 config.IpRangeConfig
	}{result1}
}

func (fake *FakeSegmentHostsNetworkConfig) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getInternalCidrMutex.RLock()
	defer fake.getInternalCidrMutex.RUnlock()
	fake.getIpListMutex.RLock()
	defer fake.getIpListMutex.RUnlock()
	fake.getIpRangeMutex.RLock()
	defer fake.getIpRangeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeSegmentHostsNetworkConfig) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ config.SegmentHostsNetworkConfig = new(FakeSegmentHostsNetworkConfig)
